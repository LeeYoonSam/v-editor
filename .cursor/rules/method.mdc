---
description: 개발 방법론과 규칙(Always)
alwaysApply: true
globs:
---

# 개발 방법론과 규칙(method)

본 문서는 일관된 개발을 위해 팀이 반드시 따를 규칙을 정의합니다. 모든 작업은 TDD(실패 → 성공 → 리팩토링) 순서를 기본으로 합니다.

## 0. 원칙(Principles)
- **단일 책임**: 함수/클래스는 하나의 이유로만 변경되도록 설계합니다.
- **불변 우선**: 가능한 한 불변 데이터 모델을 사용합니다.
- **명시적 상태**: UI 상태는 단방향 데이터 흐름으로만 변경합니다.
- **작게 나누기**: 기능을 작은 단위로 설계/구현/테스트합니다.
- **테스트 우선**: 테스트가 없으면 기능도 없습니다.

## 1. 프로젝트 구조
- 현재: 단일 모듈 `app`
- 예정: 기능/레이어 기반 멀티 모듈화(`:core:model`, `:core:media`, `:feature:home`, `:feature:editor`)

## 2. 아키텍처
- **UDF + Presenter**: Slack Circuit의 `Presenter`와 `Ui` 조합으로 상태 관리(MVI 스타일) 채택
- **레이어 분리**
  - Domain: UseCase, 엔티티, 순수 Kotlin
  - Data: 로컬 파일/스토리지 접근(서버 없음), 리포지토리
  - Presentation: Circuit `Screen`, `Presenter`, `Ui`

## 3. Circuit 사용 규칙
- `Screen`: 네비게이션 경계. 매개변수는 Parcelable/Serializable 등 안전한 타입만 노출
- `Presenter`: 순수 상태 기계. 입력(Intent/Event) → 상태(State) 단방향 전파, 사이드이펙트는 UseCase에 위임
- `Ui`: 순수 Composable. 이벤트 발행만 수행, 비즈니스 로직 금지
- 상태 객체는 value class/데이터 클래스 사용, 모든 필드는 불변으로 선언
- 네비게이션은 Circuit `Navigator` 사용. Backstack 변경은 Presenter에서만 수행

### 참고 문서 연결
- 모든 UI/상태 관련 구현 시 아래 문서를 우선 참고한다.
  - `.cursor/rules/design.mdc` (디자인 규칙/사양)
  - `.cursor/rules/glossary.mdc` (용어집/명칭 규칙)

## 4. Coroutines/Flow
- ViewModel/Presenter 스코프: `CoroutineScope`는 Circuit 제공 스코프 또는 `SupervisorJob` 기반
- 디스패처: `Dispatchers.Default`(연산), `Dispatchers.IO`(파일/미디어), UI는 `Main.immediate`
- Flow 규칙: cold flow 우선, 공유가 필요하면 `stateIn`/`shareIn` 사용, 재시도는 `retry` 정책 명시

## 5. Compose 규칙
- State Hoisting: UI는 상태 보유 금지, 상위에서 상태 주입
- Stability: `@Immutable`/`@Stable`로 재구성 비용 관리, 리스트는 `Lazy*`와 `key` 사용
- 미리보기: `@Preview`는 실제 프로덕션 상태와 최대한 동일한 파라미터로 구성
- 접근성: contentDescription, 최소 터치 영역, 대비 기준 준수

## 6. 미디어/편집 규칙
- MVP 편집은 비파괴(non-destructive) 전략: 타임라인 구성/오버레이는 메타데이터로 유지, 내보내기 시 렌더링
- 파일 접근은 SAF/MediaStore 사용, URI 기반 추상화
- 시간 단위는 ms(Long)로 통일, 프레임 정확도는 후속 단계에서 도입

## 7. 테스트 전략(TDD)
- 단위 테스트: Presenter/UseCase는 1기능 1테스트 기준으로 최소 케이스부터 작성
- UI 테스트: Compose UI는 Semantics 기반 매칭, 불안정한 대기 금지(Idling, runOnIdle)
- 미디어 I/O: 실제 I/O는 통합 테스트로 분리, 단위 테스트는 Fake/Temp 디렉터리 사용
- 커버리지 목표: 핵심 도메인/프레젠테이션 80%+
  - 네이밍: 모든 테스트 함수는 given_when_then(snake_case) 패턴을 따른다.
  - UI 테스트 식별자: 안정적인 testTag(정적 + 동적 병행)를 필수로 부여한다.

## 8. 에러 처리/로깅
- 사용자 에러 메시지와 개발자 로그 분리
- 예외는 경계에서 포착, 도메인에서는 실패 타입(Result/Either)로 전파
- 로깅 태그는 기능 기준, PII 저장 금지

## 9. Git/브랜치/커밋
- 브랜치: `feature/<scope>`, `fix/<scope>`, `chore/<scope>`
- 커밋: `test:`, `feat:`, `fix:`, `refactor:`, `docs:`, `build:` 접두어 사용
- PR: 스쿼시 머지, 최소 1명 리뷰

## 10. Gradle/빌드(메트릭/툴)
- 빌드 캐시 활성화, 구성 캐시 사용
- Slack Circuit/Metro는 버전 카탈로그(`gradle/libs.versions.toml`)로 관리
- CI에서 `./gradlew :app:assembleDebug :app:testDebugUnitTest`를 최소 게이트로 사용

## 11. 의존성/DI
- MVP: 간단한 수동 DI로 시작 → 필요 시 DI 라이브러리 도입(예: kotlin-inject/Hilt)
- Metro 도입 시 JSR-330 주석 사용 범위를 최소 API로 유지

## 12. 코드 스타일
- Kotlin 공식 컨벤션 + Detekt/Spotless 적용 권장
- 이름은 의미 중심(약어 지양), 조기 반환, 깊은 중첩 금지
- 제거된 코드 자리에는 대체 주석을 남기지 않는다(예: "제거됨").
- 함수/변수/클래스 네이밍만으로 역할이 드러나도록 의미 기반 이름을 사용한다.
- 꼭 필요한 설명(의도/경계/트릭)만 간결히 주석으로 남긴다. 자명한 주석은 금지.

## 13. Plan.md 업데이트 규칙
- 모든 작업(구현/리팩토링/문서 수정 포함) 완료 시, 반드시 `Plan.md`의 작업 보드(TODO)를 갱신한다.
- `Plan.md`에 해당 작업 항목이 없으면 적절한 카테고리(A~F) 아래 새 항목을 추가한다.
- 진행 상태 표기는 통일한다: `[ ]` 미시작, `[~]` 진행중, `[x]` 완료.
- 완료 시에는 간단한 보완 기록(무엇을, 왜) 한 줄을 함께 남긴다.
- 커밋/PR 제목은 `Plan.md`에 작성한 작업 타이틀을 그대로 사용한다.
- 작업 시작 시 `[~]`로 표기하고, 완료 직후 `[x]`로 전환한다. 누락 시 작업 미완료로 간주한다.

